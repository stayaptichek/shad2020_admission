Хэш функция: hash(x) = i, x - ключ

Хэш таблица: массив, хранит в i-й ячейке значение ключа x

Коллизия - когда hash(x)=hash(y), где x=/=y, то есть x и y соответствуют одной ячейке в таблице 

Часто используют hash(x) = x (mod M)

КАК БОРОТЬСЯ С КОЛЛИЗИЯМИ? 



МЕТОД ЦЕПОЧЕК: в каждой ячейке хранится указатель на начало списка (чтобы делать поиск) , указатель на конец списка (чтобы делать вставку)

Тогда если h(22)= h(42)=i mod10, то запишем в i-й список 22 и 42

\alpha = \frac{n}{m}, m - размер таблицы, n - число входных элементов

Тогда вставка будет за O(1), удаление и поиск за O(1+\alpha)

ГИПОТЕЗА ПРОСТОГО РАВНМОЕРНОГО ХЕШИРОВАНИЯ:
Считаем, что h(x) - случайная равномерно распределенная величина со значениями из 0, .., M-1 и пусть
P[h(x)=i, h(y)=j] = P[h(x)=i] * P[h(y)=j], то есть есть независимость в исходах.
Тогда |H| = m^|K|.

Пусть у нас есть ключи k1,...,k_n из ХТ, тогда P[ h(k_i) = h(k) ] = \sum_{j=0}^{M} \frac{1}{M^2} = \frac{1}{M}, если k_i =/= k и 1 иначе. 
Пусть len - длина цепочки в ячейке, соответствующей цепочке h(k), то есть len = |{ h(k_i)| h(k_i) = h(k) }|.

Тогда E[len] = \sum_{i=0}{n} P[h(k) = h(k_i)] <= n/M + 1 = \alpha + 1.
если \alpha держать const, то получим E[len]  = O(1).





МЕТОД ОТКРЫТОЙ АДРЕСАЦИИ: 

ЛИНЕЙНОЕ ПРОБИРОВАНИЕ
Рассмотрим [\tilde hash(x, i) = hash(x,0) + i] modM
Если не смогли вставить элемент по хэшу, то перевычисляем hash по формуле выше, сдвигая i->i+1

hash(33) = 3
hash(42) = 2
hash(22) = 2 (=hash(42)) => \tilde hash(22, 1) = hash(22, 0) + 1 = 3 (= hash(33)) => \tilde hash(22, 2) = \hash(22, 0) + 2 = 4

Таким образом полчаем хэш таблицу: nill nill 42 33 22 ...

Однако, может возникнуть некоторый казус, связанный с удалением элементов: пусть мы удалили 33, тогда 4 ячейка стала пустой и тогда организуя поиск 22, получаем, что мы должны перейти чпрез пустую ячейку, что не возможно. 
Поэтому предлаагется хранить ещё в ячейке индикатор того, что в ячейке был когда-то удален элемент.  

КВАДРАТИЧНОЕ ПРОБИРОВАНИЕ
\tilde hash(x,i) = hash(x,i) + c_1*i + c_2*i^2 modM

Хотим, чтобы пробирование пробегало все индексы

Утв. Если c_1 = c_2 = 0.5, M=2^k, тогда кв. пробирование обойдет все элементы

ДВОЙНОК ХЭШИРОВАНИЕ

\tilde hash(x,i) = hash_1(x) + i*hash_2(x) modM
Чтобы обойти все элементы, значения h_2 должны быть взаимно просты с M (тогда i*h_2 пробежит все остатки по modM)

Теор. Количество проб в хэш таблице с открытой адресацией и \alpha <1 в предположении равнмоерного хэширования <= 1/(1-\alpha)


ДИНАМИЧЕСКАЯ ХТ: если \alpha -> 1, то расширяем и перехешируем, \tilde M = k*M, k>=2  целое











